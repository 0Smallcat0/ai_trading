"""
Á∏æÊïàÊ≠∏Âõ†ÂàÜÊûêÁµÑ‰ª∂

Êèê‰æõ Brinson Ê≠∏Âõ†„ÄÅÂ§öÂ±§Á¥öÊ≠∏Âõ†„ÄÅÂü∫Ê∫ñÊØîËºÉÁ≠âÁ∏æÊïàÂàÜÊûêÂäüËÉΩ„ÄÇ
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from typing import Dict, List, Any, Optional, Tuple
import logging
from datetime import datetime, timedelta

from src.ui.utils.portfolio_analytics import PortfolioAnalytics

logger = logging.getLogger(__name__)


class PerformanceAttributionComponent:
    """Á∏æÊïàÊ≠∏Âõ†ÂàÜÊûêÁµÑ‰ª∂È°û"""

    def __init__(self):
        """ÂàùÂßãÂåñÁ∏æÊïàÊ≠∏Âõ†ÁµÑ‰ª∂"""
        self.analytics = PortfolioAnalytics()
        self.theme = self._get_theme()

    def _get_theme(self) -> Dict[str, str]:
        """Áç≤ÂèñÁï∂Ââç‰∏ªÈ°åÈÖçÁΩÆ"""
        if st.session_state.get("theme", "light") == "dark":
            return {
                "background": "#1E1E1E",
                "text": "#FFFFFF",
                "primary": "#00D4FF",
                "secondary": "#FF6B35",
                "success": "#00C851",
                "danger": "#FF4444",
                "warning": "#FFBB33",
            }
        else:
            return {
                "background": "#FFFFFF",
                "text": "#333333",
                "primary": "#1f77b4",
                "secondary": "#ff7f0e",
                "success": "#2ca02c",
                "danger": "#d62728",
                "warning": "#ff7f0e",
            }

    def render_attribution_analysis(self, portfolio_data: Dict[str, Any]) -> None:
        """Ê∏≤ÊüìÁ∏æÊïàÊ≠∏Âõ†ÂàÜÊûê

        Args:
            portfolio_data: ÊäïË≥áÁµÑÂêàÊï∏Êìö
        """
        st.subheader("üìä Á∏æÊïàÊ≠∏Âõ†ÂàÜÊûê")

        # ÂâµÂª∫Ê®ôÁ±§È†Å
        tab1, tab2, tab3, tab4 = st.tabs(
            ["Brinson Ê≠∏Âõ†", "Â§öÂ±§Á¥öÊ≠∏Âõ†", "Âü∫Ê∫ñÊØîËºÉ", "ÊôÇÈñìÂ∫èÂàóÂàÜÊûê"]
        )

        with tab1:
            self._render_brinson_attribution()

        with tab2:
            self._render_multilevel_attribution()

        with tab3:
            self._render_benchmark_comparison()

        with tab4:
            self._render_time_series_attribution()

    def render_performance_attribution(self, portfolio_data: Dict[str, Any]) -> None:
        """Ê∏≤ÊüìÁ∏æÊïàÊ≠∏Âõ†ÂàÜÊûê (Âà•ÂêçÊñπÊ≥ïÔºåËàá render_attribution_analysis Áõ∏Âêå)

        Args:
            portfolio_data: ÊäïË≥áÁµÑÂêàÊï∏ÊìöÔºåÂåÖÂê´ÊåÅÂÄâ„ÄÅÊ¨äÈáç„ÄÅÂ†±ÈÖ¨Á≠â‰ø°ÊÅØ
        """
        # Ë™øÁî®‰∏ªË¶ÅÁöÑÊ≠∏Âõ†ÂàÜÊûêÊñπÊ≥ï
        self.render_attribution_analysis(portfolio_data)

    def _render_brinson_attribution(self) -> None:
        """Ê∏≤Êüì Brinson Ê≠∏Âõ†ÂàÜÊûê"""
        st.write("### üéØ Brinson Á∏æÊïàÊ≠∏Âõ†")

        # ÂèÉÊï∏Ë®≠ÂÆö
        col1, col2 = st.columns(2)

        with col1:
            analysis_period = st.selectbox(
                "ÂàÜÊûêÊúüÈñì", ["1ÂÄãÊúà", "3ÂÄãÊúà", "6ÂÄãÊúà", "1Âπ¥"], index=2
            )

        with col2:
            sector_count = st.slider("Ë°åÊ•≠Êï∏Èáè", 3, 10, 6)

        # ÁîüÊàêÊ®°Êì¨Êï∏Êìö
        (
            portfolio_weights,
            benchmark_weights,
            portfolio_returns,
            benchmark_returns,
            sector_names,
        ) = self._generate_brinson_data(sector_count)

        # Ë®àÁÆó Brinson Ê≠∏Âõ†
        attribution_result = self.analytics.brinson_attribution(
            portfolio_weights, benchmark_weights, portfolio_returns, benchmark_returns
        )

        # È°ØÁ§∫Ê≠∏Âõ†ÁµêÊûú
        self._display_brinson_results(attribution_result)

        # Áπ™Ë£ΩÊ≠∏Âõ†ÂàÜËß£Âúñ
        self._plot_brinson_attribution(attribution_result, sector_names)

        # Ë©≥Á¥∞ÂàÜÊûêË°®
        self._display_detailed_attribution(
            portfolio_weights,
            benchmark_weights,
            portfolio_returns,
            benchmark_returns,
            sector_names,
        )

    def _display_brinson_results(self, result: Dict[str, float]) -> None:
        """È°ØÁ§∫ Brinson Ê≠∏Âõ†ÁµêÊûú"""
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric(
                "Ë≥áÁî¢ÈÖçÁΩÆÊïàÊáâ",
                f"{result['allocation_effect']:.2%}",
                help="Áî±ÊñºË≥áÁî¢ÈÖçÁΩÆ‰∏çÂêåÊñºÂü∫Ê∫ñÊâÄÁî¢ÁîüÁöÑË∂ÖÈ°çÂ†±ÈÖ¨",
            )

        with col2:
            st.metric(
                "ÈÅ∏ËÇ°ÊïàÊáâ",
                f"{result['selection_effect']:.2%}",
                help="Áî±ÊñºÂÄãËÇ°ÈÅ∏ÊìáËÉΩÂäõÊâÄÁî¢ÁîüÁöÑË∂ÖÈ°çÂ†±ÈÖ¨",
            )

        with col3:
            st.metric(
                "‰∫§‰∫íÊïàÊáâ",
                f"{result['interaction_effect']:.2%}",
                help="Ë≥áÁî¢ÈÖçÁΩÆËàáÈÅ∏ËÇ°ÊïàÊáâÁöÑ‰∫§‰∫í‰ΩúÁî®",
            )

        with col4:
            st.metric(
                "Á∏ΩË∂ÖÈ°çÂ†±ÈÖ¨",
                f"{result['total_excess_return']:.2%}",
                help="Áõ∏Â∞çÊñºÂü∫Ê∫ñÁöÑÁ∏ΩË∂ÖÈ°çÂ†±ÈÖ¨",
            )

    def _plot_brinson_attribution(
        self, result: Dict[str, float], sector_names: List[str]
    ) -> None:
        """Áπ™Ë£Ω Brinson Ê≠∏Âõ†Âúñ"""
        effects = ["Ë≥áÁî¢ÈÖçÁΩÆÊïàÊáâ", "ÈÅ∏ËÇ°ÊïàÊáâ", "‰∫§‰∫íÊïàÊáâ"]
        values = [
            result["allocation_effect"],
            result["selection_effect"],
            result["interaction_effect"],
        ]

        # Ë®≠ÂÆöÈ°èËâ≤
        colors = [
            self.theme["success"] if v >= 0 else self.theme["danger"] for v in values
        ]

        fig = go.Figure(
            data=[
                go.Bar(
                    x=effects,
                    y=values,
                    marker_color=colors,
                    text=[f"{v:.2%}" for v in values],
                    textposition="auto",
                )
            ]
        )

        fig.update_layout(
            title="Brinson Á∏æÊïàÊ≠∏Âõ†ÂàÜËß£",
            xaxis_title="Ê≠∏Âõ†ÊïàÊáâ",
            yaxis_title="Ë∂ÖÈ°çÂ†±ÈÖ¨Ë≤¢Áçª",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=400,
        )

        # Ê∑ªÂä†Èõ∂Á∑ö
        fig.add_hline(y=0, line_dash="dash", line_color=self.theme["text"], opacity=0.5)

        st.plotly_chart(fig, use_container_width=True)

    def _display_detailed_attribution(
        self,
        portfolio_weights: np.ndarray,
        benchmark_weights: np.ndarray,
        portfolio_returns: np.ndarray,
        benchmark_returns: np.ndarray,
        sector_names: List[str],
    ) -> None:
        """È°ØÁ§∫Ë©≥Á¥∞Ê≠∏Âõ†ÂàÜÊûêË°®"""
        st.write("#### Ë©≥Á¥∞Ê≠∏Âõ†ÂàÜÊûê")

        # Ë®àÁÆóÂêÑË°åÊ•≠ÁöÑÊ≠∏Âõ†ÊïàÊáâ
        weight_diff = portfolio_weights - benchmark_weights
        return_diff = portfolio_returns - benchmark_returns

        allocation_contrib = weight_diff * benchmark_returns
        selection_contrib = benchmark_weights * return_diff
        interaction_contrib = weight_diff * return_diff

        # ÂâµÂª∫Ë©≥Á¥∞Ë°®Ê†º
        detailed_df = pd.DataFrame(
            {
                "Ë°åÊ•≠": sector_names,
                "ÊäïË≥áÁµÑÂêàÊ¨äÈáç": [f"{w:.1%}" for w in portfolio_weights],
                "Âü∫Ê∫ñÊ¨äÈáç": [f"{w:.1%}" for w in benchmark_weights],
                "Ê¨äÈáçÂ∑ÆÁï∞": [f"{w:+.1%}" for w in weight_diff],
                "ÊäïË≥áÁµÑÂêàÂ†±ÈÖ¨": [f"{r:.2%}" for r in portfolio_returns],
                "Âü∫Ê∫ñÂ†±ÈÖ¨": [f"{r:.2%}" for r in benchmark_returns],
                "Â†±ÈÖ¨Â∑ÆÁï∞": [f"{r:+.2%}" for r in return_diff],
                "ÈÖçÁΩÆË≤¢Áçª": [f"{c:+.2%}" for c in allocation_contrib],
                "ÈÅ∏ËÇ°Ë≤¢Áçª": [f"{c:+.2%}" for c in selection_contrib],
                "‰∫§‰∫íË≤¢Áçª": [f"{c:+.2%}" for c in interaction_contrib],
            }
        )

        st.dataframe(detailed_df, use_container_width=True)

    def _render_multilevel_attribution(self) -> None:
        """Ê∏≤ÊüìÂ§öÂ±§Á¥öÊ≠∏Âõ†"""
        st.write("### üèóÔ∏è Â§öÂ±§Á¥öÊ≠∏Âõ†ÂàÜÊûê")

        # Ê≠∏Âõ†Â±§Á¥öÈÅ∏Êìá
        attribution_levels = st.multiselect(
            "ÈÅ∏ÊìáÊ≠∏Âõ†Â±§Á¥ö",
            ["GICS Ë°åÊ•≠", "È¢®Ê†ºÂõ†Â≠ê", "ÂÄãËÇ°Â±§Á¥ö", "ÂúãÂÆ∂/Âú∞ÂçÄ"],
            default=["GICS Ë°åÊ•≠", "È¢®Ê†ºÂõ†Â≠ê"],
        )

        if attribution_levels:
            # ÁÇ∫ÊØèÂÄãÂ±§Á¥öÂâµÂª∫ÂàÜÊûê
            for level in attribution_levels:
                with st.expander(f"üìà {level} Ê≠∏Âõ†ÂàÜÊûê", expanded=True):
                    self._render_level_attribution(level)

    def _render_level_attribution(self, level: str) -> None:
        """Ê∏≤ÊüìÁâπÂÆöÂ±§Á¥öÁöÑÊ≠∏Âõ†ÂàÜÊûê"""
        if level == "GICS Ë°åÊ•≠":
            self._render_sector_attribution()
        elif level == "È¢®Ê†ºÂõ†Â≠ê":
            self._render_style_attribution()
        elif level == "ÂÄãËÇ°Â±§Á¥ö":
            self._render_stock_attribution()
        elif level == "ÂúãÂÆ∂/Âú∞ÂçÄ":
            self._render_country_attribution()

    def _render_sector_attribution(self) -> None:
        """Ê∏≤ÊüìË°åÊ•≠Ê≠∏Âõ†"""
        # ÁîüÊàê GICS Ë°åÊ•≠Êï∏Êìö
        sectors = [
            "Ë≥áË®äÁßëÊäÄ",
            "ÈáëËûç",
            "ÈÜ´ÁôÇ‰øùÂÅ•",
            "Ê∂àË≤ªÂøÖÈúÄÂìÅ",
            "Â∑•Ê•≠",
            "ÈÄöË®äÊúçÂãô",
            "Ê∂àË≤ªÈùûÂøÖÈúÄÂìÅ",
            "ËÉΩÊ∫ê",
        ]

        # Ê®°Êì¨Ë°åÊ•≠Ê≠∏Âõ†Êï∏Êìö
        np.random.seed(42)
        sector_attribution = np.random.normal(0, 0.02, len(sectors))

        # Áπ™Ë£ΩË°åÊ•≠Ê≠∏Âõ†Âúñ
        colors = [
            self.theme["success"] if attr >= 0 else self.theme["danger"]
            for attr in sector_attribution
        ]

        fig = go.Figure(
            data=[
                go.Bar(
                    x=sectors,
                    y=sector_attribution,
                    marker_color=colors,
                    text=[f"{attr:+.2%}" for attr in sector_attribution],
                    textposition="auto",
                )
            ]
        )

        fig.update_layout(
            title="GICS Ë°åÊ•≠Ê≠∏Âõ†Ë≤¢Áçª",
            xaxis_title="Ë°åÊ•≠",
            yaxis_title="Ê≠∏Âõ†Ë≤¢Áçª",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=300,
        )

        fig.add_hline(y=0, line_dash="dash", line_color=self.theme["text"], opacity=0.5)

        st.plotly_chart(fig, use_container_width=True)

    def _render_style_attribution(self) -> None:
        """Ê∏≤ÊüìÈ¢®Ê†ºÂõ†Â≠êÊ≠∏Âõ†"""
        style_factors = ["ÂÉπÂÄº", "ÊàêÈï∑", "ÂìÅË≥™", "ÂãïËÉΩ", "‰ΩéÊ≥¢Âãï", "Â∞èÂûãËÇ°"]

        # Ê®°Êì¨È¢®Ê†ºÂõ†Â≠êÊ≠∏Âõ†
        np.random.seed(43)
        style_attribution = np.random.normal(0, 0.015, len(style_factors))

        # ÂâµÂª∫Èõ∑ÈÅîÂúñ
        fig = go.Figure()

        fig.add_trace(
            go.Scatterpolar(
                r=np.abs(style_attribution),
                theta=style_factors,
                fill="toself",
                name="È¢®Ê†ºÂõ†Â≠êÊö¥Èú≤",
                line_color=self.theme["primary"],
            )
        )

        fig.update_layout(
            polar=dict(
                radialaxis=dict(
                    visible=True, range=[0, max(np.abs(style_attribution)) * 1.2]
                )
            ),
            title="È¢®Ê†ºÂõ†Â≠êÊ≠∏Âõ†ÂàÜÊûê",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=400,
        )

        st.plotly_chart(fig, use_container_width=True)

        # È¢®Ê†ºÂõ†Â≠êË°®Ê†º
        style_df = pd.DataFrame(
            {
                "È¢®Ê†ºÂõ†Â≠ê": style_factors,
                "Ê≠∏Âõ†Ë≤¢Áçª": [f"{attr:+.2%}" for attr in style_attribution],
                "Ë≤¢ÁçªÊéíÂêç": range(1, len(style_factors) + 1),
            }
        )

        # ÊåâË≤¢ÁçªÊéíÂ∫è
        style_df = style_df.reindex(
            style_df["Ê≠∏Âõ†Ë≤¢Áçª"]
            .str.replace("%", "")
            .astype(float)
            .abs()
            .sort_values(ascending=False)
            .index
        )
        style_df["Ë≤¢ÁçªÊéíÂêç"] = range(1, len(style_factors) + 1)

        st.dataframe(style_df, use_container_width=True)

    def _render_stock_attribution(self) -> None:
        """Ê∏≤ÊüìÂÄãËÇ°Ê≠∏Âõ†"""
        # Ê®°Êì¨Ââç10Â§ßÊåÅËÇ°ÁöÑÊ≠∏Âõ†Ë≤¢Áçª
        stocks = [f"ËÇ°Á•® {i+1}" for i in range(10)]

        np.random.seed(44)
        stock_attribution = np.random.normal(0, 0.01, len(stocks))
        stock_weights = np.random.uniform(0.02, 0.08, len(stocks))

        # ÊåâÊ≠∏Âõ†Ë≤¢ÁçªÊéíÂ∫è
        sorted_indices = np.argsort(stock_attribution)[::-1]

        stock_df = pd.DataFrame(
            {
                "ËÇ°Á•®": [stocks[i] for i in sorted_indices],
                "Ê¨äÈáç": [f"{stock_weights[i]:.1%}" for i in sorted_indices],
                "Ê≠∏Âõ†Ë≤¢Áçª": [f"{stock_attribution[i]:+.2%}" for i in sorted_indices],
                "Ë≤¢ÁçªÈ°ûÂûã": [
                    "Ê≠£Ë≤¢Áçª" if stock_attribution[i] >= 0 else "Ë≤†Ë≤¢Áçª"
                    for i in sorted_indices
                ],
            }
        )

        st.dataframe(stock_df, use_container_width=True)

    def _render_country_attribution(self) -> None:
        """Ê∏≤ÊüìÂúãÂÆ∂/Âú∞ÂçÄÊ≠∏Âõ†"""
        countries = ["ÁæéÂúã", "‰∏≠Âúã", "Êó•Êú¨", "Âæ∑Âúã", "Ëã±Âúã", "Ê≥ïÂúã", "Âè∞ÁÅ£", "ÈüìÂúã"]

        np.random.seed(45)
        country_attribution = np.random.normal(0, 0.01, len(countries))

        # ‰∏ñÁïåÂú∞ÂúñË¶ñË¶∫ÂåñÔºàÁ∞°ÂåñÁâàÔºâ
        colors = [
            self.theme["success"] if attr >= 0 else self.theme["danger"]
            for attr in country_attribution
        ]

        fig = go.Figure(
            data=[
                go.Bar(
                    x=countries,
                    y=country_attribution,
                    marker_color=colors,
                    text=[f"{attr:+.2%}" for attr in country_attribution],
                    textposition="auto",
                )
            ]
        )

        fig.update_layout(
            title="ÂúãÂÆ∂/Âú∞ÂçÄÊ≠∏Âõ†Ë≤¢Áçª",
            xaxis_title="ÂúãÂÆ∂/Âú∞ÂçÄ",
            yaxis_title="Ê≠∏Âõ†Ë≤¢Áçª",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=300,
        )

        fig.add_hline(y=0, line_dash="dash", line_color=self.theme["text"], opacity=0.5)

        st.plotly_chart(fig, use_container_width=True)

    def _render_benchmark_comparison(self) -> None:
        """Ê∏≤ÊüìÂü∫Ê∫ñÊØîËºÉÂàÜÊûê"""
        st.write("### üìà Âü∫Ê∫ñÊØîËºÉÂàÜÊûê")

        # Âü∫Ê∫ñÈÅ∏Êìá
        benchmarks = st.multiselect(
            "ÈÅ∏ÊìáÊØîËºÉÂü∫Ê∫ñ",
            ["MSCI ‰∏ñÁïåÊåáÊï∏", "S&P 500", "Âè∞ÁÅ£Âä†Ê¨äÊåáÊï∏", "MSCI Êñ∞ËààÂ∏ÇÂ†¥", "Ëá™ÂÆöÁæ©Âü∫Ê∫ñ"],
            default=["MSCI ‰∏ñÁïåÊåáÊï∏", "S&P 500"],
        )

        if benchmarks:
            # ÁîüÊàêÊØîËºÉÊï∏Êìö
            comparison_data = self._generate_benchmark_comparison_data(benchmarks)

            # Á∏æÊïàÊØîËºÉË°®
            self._display_benchmark_comparison_table(comparison_data)

            # Á¥ØÁ©çÂ†±ÈÖ¨Âúñ
            self._plot_cumulative_returns_comparison(comparison_data)

            # È¢®Èö™Ë™øÊï¥ÂæåÁ∏æÊïà
            self._display_risk_adjusted_metrics(comparison_data)

    def _display_benchmark_comparison_table(self, data: Dict[str, Any]) -> None:
        """È°ØÁ§∫Âü∫Ê∫ñÊØîËºÉË°®"""
        st.write("#### Á∏æÊïàÊØîËºÉÊëòË¶Å")

        comparison_df = pd.DataFrame(data["summary"])
        st.dataframe(comparison_df, use_container_width=True)

    def _plot_cumulative_returns_comparison(self, data: Dict[str, Any]) -> None:
        """Áπ™Ë£ΩÁ¥ØÁ©çÂ†±ÈÖ¨ÊØîËºÉÂúñ"""
        fig = go.Figure()

        for benchmark, returns in data["cumulative_returns"].items():
            fig.add_trace(
                go.Scatter(
                    x=data["dates"],
                    y=returns,
                    mode="lines",
                    name=benchmark,
                    line=dict(width=2),
                )
            )

        fig.update_layout(
            title="Á¥ØÁ©çÂ†±ÈÖ¨ÊØîËºÉ",
            xaxis_title="Êó•Êúü",
            yaxis_title="Á¥ØÁ©çÂ†±ÈÖ¨Áéá",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=400,
            hovermode="x unified",
        )

        st.plotly_chart(fig, use_container_width=True)

    def _display_risk_adjusted_metrics(self, data: Dict[str, Any]) -> None:
        """È°ØÁ§∫È¢®Èö™Ë™øÊï¥ÂæåÊåáÊ®ô"""
        st.write("#### È¢®Èö™Ë™øÊï¥ÂæåÁ∏æÊïàÊåáÊ®ô")

        metrics_df = pd.DataFrame(data["risk_metrics"])
        st.dataframe(metrics_df, use_container_width=True)

    def _render_time_series_attribution(self) -> None:
        """Ê∏≤ÊüìÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†"""
        st.write("### üìÖ ÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†ÂàÜÊûê")

        # ÊôÇÈñìÁØÑÂúçÈÅ∏Êìá
        col1, col2 = st.columns(2)

        with col1:
            frequency = st.selectbox("ÂàÜÊûêÈ†ªÁéá", ["Êó•", "ÈÄ±", "Êúà", "Â≠£"], index=2)

        with col2:
            lookback_period = st.selectbox(
                "ÂõûÈ°ßÊúüÈñì", ["6ÂÄãÊúà", "1Âπ¥", "2Âπ¥", "3Âπ¥"], index=1
            )

        # ÁîüÊàêÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†Êï∏Êìö
        ts_data = self._generate_time_series_attribution_data(
            frequency, lookback_period
        )

        # Áπ™Ë£ΩÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†Âúñ
        self._plot_time_series_attribution(ts_data, frequency)

        # Ê≠∏Âõ†Á©©ÂÆöÊÄßÂàÜÊûê
        self._analyze_attribution_stability(ts_data)

    def _plot_time_series_attribution(
        self, data: Dict[str, Any], frequency: str
    ) -> None:
        """Áπ™Ë£ΩÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†Âúñ"""
        fig = make_subplots(
            rows=2,
            cols=1,
            shared_xaxes=True,
            subplot_titles=("Ê≠∏Âõ†ÊïàÊáâÊôÇÈñìÂ∫èÂàó", "Á¥ØÁ©çÊ≠∏Âõ†Ë≤¢Áçª"),
            vertical_spacing=0.1,
        )

        # Ê≠∏Âõ†ÊïàÊáâÊôÇÈñìÂ∫èÂàó
        for effect, values in data["attribution_series"].items():
            fig.add_trace(
                go.Scatter(
                    x=data["dates"],
                    y=values,
                    mode="lines",
                    name=effect,
                    line=dict(width=2),
                ),
                row=1,
                col=1,
            )

        # Á¥ØÁ©çÊ≠∏Âõ†
        for effect, values in data["cumulative_attribution"].items():
            fig.add_trace(
                go.Scatter(
                    x=data["dates"],
                    y=values,
                    mode="lines",
                    name=f"{effect} (Á¥ØÁ©ç)",
                    line=dict(width=2, dash="dash"),
                    showlegend=False,
                ),
                row=2,
                col=1,
            )

        fig.update_layout(
            title=f"{frequency}Â∫¶Ê≠∏Âõ†ÂàÜÊûêÊôÇÈñìÂ∫èÂàó",
            plot_bgcolor=self.theme["background"],
            paper_bgcolor=self.theme["background"],
            font_color=self.theme["text"],
            height=600,
        )

        fig.update_xaxes(title_text="Êó•Êúü", row=2, col=1)
        fig.update_yaxes(title_text="Ê≠∏Âõ†Ë≤¢Áçª", row=1, col=1)
        fig.update_yaxes(title_text="Á¥ØÁ©çË≤¢Áçª", row=2, col=1)

        st.plotly_chart(fig, use_container_width=True)

    def _analyze_attribution_stability(self, data: Dict[str, Any]) -> None:
        """ÂàÜÊûêÊ≠∏Âõ†Á©©ÂÆöÊÄß"""
        st.write("#### Ê≠∏Âõ†Á©©ÂÆöÊÄßÂàÜÊûê")

        stability_metrics = {}

        for effect, values in data["attribution_series"].items():
            values_array = np.array(values)
            stability_metrics[effect] = {
                "Âπ≥ÂùáÂÄº": np.mean(values_array),
                "Ê®ôÊ∫ñÂ∑Æ": np.std(values_array),
                "ËÆäÁï∞‰øÇÊï∏": (
                    np.std(values_array) / np.abs(np.mean(values_array))
                    if np.mean(values_array) != 0
                    else np.inf
                ),
                "Ê≠£ÂÄºÊØî‰æã": np.mean(values_array > 0),
            }

        stability_df = pd.DataFrame(stability_metrics).T
        stability_df = stability_df.round(4)

        st.dataframe(stability_df, use_container_width=True)

        # Á©©ÂÆöÊÄßË©ïÁ¥ö
        st.write("#### Á©©ÂÆöÊÄßË©ïÁ¥ö")
        for effect, metrics in stability_metrics.items():
            cv = metrics["ËÆäÁï∞‰øÇÊï∏"]
            if cv < 0.5:
                rating = "üü¢ È´òÁ©©ÂÆöÊÄß"
            elif cv < 1.0:
                rating = "üü° ‰∏≠Á≠âÁ©©ÂÆöÊÄß"
            else:
                rating = "üî¥ ‰ΩéÁ©©ÂÆöÊÄß"

            st.write(f"‚Ä¢ **{effect}**: {rating} (ËÆäÁï∞‰øÇÊï∏: {cv:.2f})")

    def _generate_brinson_data(
        self, sector_count: int
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, List[str]]:
        """ÁîüÊàê Brinson Ê≠∏Âõ†Êï∏Êìö"""
        np.random.seed(42)

        # ÁîüÊàêÊ¨äÈáç
        portfolio_weights = np.random.dirichlet(np.ones(sector_count))
        benchmark_weights = np.random.dirichlet(np.ones(sector_count))

        # ÁîüÊàêÂ†±ÈÖ¨Áéá
        portfolio_returns = np.random.normal(0.08, 0.15, sector_count)
        benchmark_returns = np.random.normal(0.06, 0.12, sector_count)

        # Ë°åÊ•≠ÂêçÁ®±
        sector_names = [f"Ë°åÊ•≠ {i+1}" for i in range(sector_count)]

        return (
            portfolio_weights,
            benchmark_weights,
            portfolio_returns,
            benchmark_returns,
            sector_names,
        )

    def _generate_benchmark_comparison_data(
        self, benchmarks: List[str]
    ) -> Dict[str, Any]:
        """ÁîüÊàêÂü∫Ê∫ñÊØîËºÉÊï∏Êìö"""
        np.random.seed(42)

        # ÁîüÊàêÊó•Êúü
        dates = pd.date_range(end=pd.Timestamp.now(), periods=252, freq="D")

        # ÁîüÊàêÁ¥ØÁ©çÂ†±ÈÖ¨
        cumulative_returns = {}
        summary_data = []
        risk_metrics_data = []

        for i, benchmark in enumerate(benchmarks):
            # ÁîüÊàêÂ†±ÈÖ¨ÁéáÂ∫èÂàó
            daily_returns = np.random.normal(
                0.0008 + i * 0.0002, 0.015 + i * 0.002, len(dates)
            )
            cumulative = (1 + pd.Series(daily_returns)).cumprod() - 1
            cumulative_returns[benchmark] = cumulative.values

            # Ë®àÁÆóÊëòË¶ÅÁµ±Ë®à
            annual_return = np.mean(daily_returns) * 252
            annual_vol = np.std(daily_returns) * np.sqrt(252)
            sharpe = annual_return / annual_vol
            max_dd = np.min(cumulative - cumulative.expanding().max())

            summary_data.append(
                {
                    "Âü∫Ê∫ñ": benchmark,
                    "Âπ¥ÂåñÂ†±ÈÖ¨": f"{annual_return:.2%}",
                    "Âπ¥ÂåñÊ≥¢Âãï": f"{annual_vol:.2%}",
                    "ÊúÄÂ§ßÂõûÊí§": f"{max_dd:.2%}",
                }
            )

            risk_metrics_data.append(
                {
                    "Âü∫Ê∫ñ": benchmark,
                    "Â§èÊôÆÊØîÁéá": f"{sharpe:.3f}",
                    "VaR (95%)": f"{np.percentile(daily_returns, 5):.2%}",
                    "ÂÅèÂ∫¶": f"{pd.Series(daily_returns).skew():.3f}",
                    "Â≥∞Â∫¶": f"{pd.Series(daily_returns).kurtosis():.3f}",
                }
            )

        return {
            "dates": dates,
            "cumulative_returns": cumulative_returns,
            "summary": summary_data,
            "risk_metrics": risk_metrics_data,
        }

    def _generate_time_series_attribution_data(
        self, frequency: str, lookback: str
    ) -> Dict[str, Any]:
        """ÁîüÊàêÊôÇÈñìÂ∫èÂàóÊ≠∏Âõ†Êï∏Êìö"""
        np.random.seed(42)

        # Á¢∫ÂÆöÊúüÈñìÈï∑Â∫¶
        period_map = {"6ÂÄãÊúà": 126, "1Âπ¥": 252, "2Âπ¥": 504, "3Âπ¥": 756}
        n_days = period_map.get(lookback, 252)

        # Á¢∫ÂÆöÈ†ªÁéá
        freq_map = {"Êó•": 1, "ÈÄ±": 5, "Êúà": 22, "Â≠£": 66}
        freq_days = freq_map.get(frequency, 22)

        n_periods = n_days // freq_days
        dates = pd.date_range(
            end=pd.Timestamp.now(), periods=n_periods, freq=f"{freq_days}D"
        )

        # ÁîüÊàêÊ≠∏Âõ†ÊôÇÈñìÂ∫èÂàó
        allocation_effect = np.random.normal(0.001, 0.01, n_periods)
        selection_effect = np.random.normal(0.002, 0.015, n_periods)
        interaction_effect = np.random.normal(0, 0.005, n_periods)

        # Ë®àÁÆóÁ¥ØÁ©çÊ≠∏Âõ†
        cumulative_allocation = np.cumsum(allocation_effect)
        cumulative_selection = np.cumsum(selection_effect)
        cumulative_interaction = np.cumsum(interaction_effect)

        return {
            "dates": dates,
            "attribution_series": {
                "Ë≥áÁî¢ÈÖçÁΩÆÊïàÊáâ": allocation_effect,
                "ÈÅ∏ËÇ°ÊïàÊáâ": selection_effect,
                "‰∫§‰∫íÊïàÊáâ": interaction_effect,
            },
            "cumulative_attribution": {
                "Ë≥áÁî¢ÈÖçÁΩÆÊïàÊáâ": cumulative_allocation,
                "ÈÅ∏ËÇ°ÊïàÊáâ": cumulative_selection,
                "‰∫§‰∫íÊïàÊáâ": cumulative_interaction,
            },
        }
