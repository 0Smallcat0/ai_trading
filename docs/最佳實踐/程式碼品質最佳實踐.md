# ç¨‹å¼ç¢¼å“è³ªæœ€ä½³å¯¦è¸

**ç‰ˆæœ¬**: v2.0  
**æ›´æ–°æ—¥æœŸ**: 2025-01-13  
**é©ç”¨ç¯„åœ**: AI è‚¡ç¥¨è‡ªå‹•äº¤æ˜“ç³»çµ±

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æª”ç¸½çµäº† AI è‚¡ç¥¨è‡ªå‹•äº¤æ˜“ç³»çµ±é–‹ç™¼éç¨‹ä¸­çš„ç¨‹å¼ç¢¼å“è³ªæœ€ä½³å¯¦è¸ï¼Œå¹«åŠ©é–‹ç™¼è€…å¯«å‡ºé«˜å“è³ªã€å¯ç¶­è­·çš„ç¨‹å¼ç¢¼ã€‚

## ğŸ¯ æ ¸å¿ƒåŸå‰‡

### 1. SOLID åŸå‰‡

#### 1.1 å–®ä¸€è·è²¬åŸå‰‡ (SRP)
```python
# âŒ é•å SRPï¼šä¸€å€‹é¡åˆ¥è™•ç†å¤šç¨®è·è²¬
class TradingManager:
    def calculate_risk(self):
        pass
    
    def execute_trade(self):
        pass
    
    def send_notification(self):
        pass

# âœ… éµå¾ª SRPï¼šè·è²¬åˆ†é›¢
class RiskCalculator:
    def calculate_risk(self):
        pass

class TradeExecutor:
    def execute_trade(self):
        pass

class NotificationService:
    def send_notification(self):
        pass
```

#### 1.2 é–‹æ”¾å°é–‰åŸå‰‡ (OCP)
```python
# âœ… ä½¿ç”¨ç­–ç•¥æ¨¡å¼å¯¦ç¾ OCP
from abc import ABC, abstractmethod

class TradingStrategy(ABC):
    @abstractmethod
    def execute(self, market_data):
        pass

class MovingAverageStrategy(TradingStrategy):
    def execute(self, market_data):
        # ç§»å‹•å¹³å‡ç­–ç•¥å¯¦ç¾
        pass

class RSIStrategy(TradingStrategy):
    def execute(self, market_data):
        # RSI ç­–ç•¥å¯¦ç¾
        pass

class TradingEngine:
    def __init__(self, strategy: TradingStrategy):
        self.strategy = strategy
    
    def run(self, market_data):
        return self.strategy.execute(market_data)
```

### 2. DRY åŸå‰‡ (Don't Repeat Yourself)

#### 2.1 æå–å…±ç”¨é‚è¼¯
```python
# âŒ é‡è¤‡ç¨‹å¼ç¢¼
def calculate_sma_20(prices):
    return sum(prices[-20:]) / 20

def calculate_sma_50(prices):
    return sum(prices[-50:]) / 50

# âœ… æå–å…±ç”¨é‚è¼¯
def calculate_sma(prices, period):
    """è¨ˆç®—ç°¡å–®ç§»å‹•å¹³å‡."""
    if len(prices) < period:
        raise ValueError(f"åƒ¹æ ¼æ•¸æ“šä¸è¶³ {period} æœŸ")
    return sum(prices[-period:]) / period

def calculate_sma_20(prices):
    return calculate_sma(prices, 20)

def calculate_sma_50(prices):
    return calculate_sma(prices, 50)
```

### 3. KISS åŸå‰‡ (Keep It Simple, Stupid)

#### 3.1 ç°¡åŒ–è¤‡é›œé‚è¼¯
```python
# âŒ éæ–¼è¤‡é›œ
def should_buy(price, sma_20, sma_50, rsi, volume, prev_volume):
    if price > sma_20 and sma_20 > sma_50 and rsi < 70 and rsi > 30:
        if volume > prev_volume * 1.5:
            return True
        else:
            return False
    else:
        return False

# âœ… ç°¡åŒ–ä¸¦æé«˜å¯è®€æ€§
def should_buy(market_data):
    """åˆ¤æ–·æ˜¯å¦æ‡‰è©²è²·å…¥."""
    price_trend_up = market_data.price > market_data.sma_20 > market_data.sma_50
    rsi_in_range = 30 < market_data.rsi < 70
    volume_increased = market_data.volume > market_data.prev_volume * 1.5
    
    return price_trend_up and rsi_in_range and volume_increased
```

## ğŸ”§ ç¨‹å¼ç¢¼çµæ§‹æœ€ä½³å¯¦è¸

### 1. å‡½æ•¸è¨­è¨ˆ

#### 1.1 å‡½æ•¸é•·åº¦å’Œè¤‡é›œåº¦
```python
# âœ… ä¿æŒå‡½æ•¸ç°¡çŸ­å’Œå°ˆæ³¨
def validate_trade_parameters(symbol: str, quantity: int, price: float) -> None:
    """é©—è­‰äº¤æ˜“åƒæ•¸.
    
    Args:
        symbol: è‚¡ç¥¨ä»£ç¢¼
        quantity: äº¤æ˜“æ•¸é‡
        price: äº¤æ˜“åƒ¹æ ¼
        
    Raises:
        ValueError: ç•¶åƒæ•¸ç„¡æ•ˆæ™‚
    """
    if not symbol or not symbol.isalpha():
        raise ValueError("è‚¡ç¥¨ä»£ç¢¼å¿…é ˆç‚ºæœ‰æ•ˆçš„å­—æ¯çµ„åˆ")
    
    if quantity <= 0:
        raise ValueError("äº¤æ˜“æ•¸é‡å¿…é ˆå¤§æ–¼é›¶")
    
    if price <= 0:
        raise ValueError("äº¤æ˜“åƒ¹æ ¼å¿…é ˆå¤§æ–¼é›¶")

def calculate_position_size(account_balance: float, risk_pct: float) -> int:
    """è¨ˆç®—å»ºè­°å€‰ä½å¤§å°."""
    validate_account_balance(account_balance)
    validate_risk_percentage(risk_pct)
    
    risk_amount = account_balance * risk_pct
    return int(risk_amount / 100)  # å‡è¨­æ¯è‚¡ 100 å…ƒ
```

#### 1.2 åƒæ•¸è¨­è¨ˆ
```python
# âŒ åƒæ•¸éå¤š
def create_order(symbol, side, quantity, price, order_type, time_in_force, 
                stop_price, trail_amount, good_till_date):
    pass

# âœ… ä½¿ç”¨æ•¸æ“šé¡åˆ¥æˆ–å­—å…¸
from dataclasses import dataclass
from typing import Optional
from datetime import datetime

@dataclass
class OrderParams:
    symbol: str
    side: str  # 'buy' or 'sell'
    quantity: int
    price: float
    order_type: str = 'limit'
    time_in_force: str = 'day'
    stop_price: Optional[float] = None
    trail_amount: Optional[float] = None
    good_till_date: Optional[datetime] = None

def create_order(params: OrderParams):
    """å‰µå»ºè¨‚å–®."""
    validate_order_params(params)
    return execute_order(params)
```

### 2. é¡åˆ¥è¨­è¨ˆ

#### 2.1 é¡åˆ¥è·è²¬åˆ†é›¢
```python
# âœ… è‰¯å¥½çš„é¡åˆ¥è¨­è¨ˆ
class Portfolio:
    """æŠ•è³‡çµ„åˆç®¡ç†."""
    
    def __init__(self, initial_balance: float):
        self._balance = initial_balance
        self._positions = {}
        self._transaction_history = []
    
    def add_position(self, symbol: str, quantity: int, price: float) -> None:
        """æ·»åŠ æŒå€‰."""
        if symbol in self._positions:
            self._positions[symbol] += quantity
        else:
            self._positions[symbol] = quantity
        
        self._record_transaction('buy', symbol, quantity, price)
    
    def get_total_value(self, current_prices: dict) -> float:
        """è¨ˆç®—æŠ•è³‡çµ„åˆç¸½å€¼."""
        position_value = sum(
            quantity * current_prices.get(symbol, 0)
            for symbol, quantity in self._positions.items()
        )
        return self._balance + position_value
    
    def _record_transaction(self, action: str, symbol: str, 
                          quantity: int, price: float) -> None:
        """è¨˜éŒ„äº¤æ˜“æ­·å²."""
        transaction = {
            'timestamp': datetime.now(),
            'action': action,
            'symbol': symbol,
            'quantity': quantity,
            'price': price
        }
        self._transaction_history.append(transaction)
```

### 3. éŒ¯èª¤è™•ç†

#### 3.1 ç•°å¸¸å±¤æ¬¡çµæ§‹
```python
# âœ… å»ºç«‹æ¸…æ™°çš„ç•°å¸¸å±¤æ¬¡
class TradingSystemError(Exception):
    """äº¤æ˜“ç³»çµ±åŸºç¤ç•°å¸¸."""
    pass

class ValidationError(TradingSystemError):
    """åƒæ•¸é©—è­‰éŒ¯èª¤."""
    pass

class InsufficientFundsError(TradingSystemError):
    """è³‡é‡‘ä¸è¶³éŒ¯èª¤."""
    pass

class MarketDataError(TradingSystemError):
    """å¸‚å ´æ•¸æ“šéŒ¯èª¤."""
    pass

class NetworkError(TradingSystemError):
    """ç¶²è·¯é€£æ¥éŒ¯èª¤."""
    pass

# ä½¿ç”¨å…·é«”ç•°å¸¸
def place_order(order_params):
    try:
        validate_order(order_params)
        check_funds(order_params)
        submit_to_broker(order_params)
    except ValidationError as e:
        logger.error("è¨‚å–®é©—è­‰å¤±æ•—: %s", e)
        raise
    except InsufficientFundsError as e:
        logger.warning("è³‡é‡‘ä¸è¶³: %s", e)
        raise
    except NetworkError as e:
        logger.error("ç¶²è·¯éŒ¯èª¤: %s", e)
        # å¯èƒ½éœ€è¦é‡è©¦
        raise
```

#### 3.2 éŒ¯èª¤æ¢å¾©ç­–ç•¥
```python
import time
from functools import wraps

def retry_on_network_error(max_retries=3, delay=1.0):
    """ç¶²è·¯éŒ¯èª¤é‡è©¦è£é£¾å™¨."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_retries):
                try:
                    return func(*args, **kwargs)
                except NetworkError as e:
                    if attempt == max_retries - 1:
                        raise
                    logger.warning(
                        "ç¶²è·¯éŒ¯èª¤ï¼Œç¬¬ %d æ¬¡é‡è©¦: %s", 
                        attempt + 1, e
                    )
                    time.sleep(delay * (2 ** attempt))  # æŒ‡æ•¸é€€é¿
            return None
        return wrapper
    return decorator

@retry_on_network_error(max_retries=3)
def fetch_market_data(symbol):
    """ç²å–å¸‚å ´æ•¸æ“š."""
    # å¯èƒ½æ‹‹å‡º NetworkError çš„ç¶²è·¯è«‹æ±‚
    pass
```

## ğŸ“Š æ¸¬è©¦æœ€ä½³å¯¦è¸

### 1. æ¸¬è©¦çµæ§‹

#### 1.1 AAA æ¨¡å¼ (Arrange, Act, Assert)
```python
def test_portfolio_add_position():
    """æ¸¬è©¦æ·»åŠ æŒå€‰åŠŸèƒ½."""
    # Arrange - æº–å‚™æ¸¬è©¦æ•¸æ“š
    portfolio = Portfolio(initial_balance=100000)
    symbol = "AAPL"
    quantity = 100
    price = 150.0
    
    # Act - åŸ·è¡Œè¢«æ¸¬è©¦çš„æ“ä½œ
    portfolio.add_position(symbol, quantity, price)
    
    # Assert - é©—è­‰çµæœ
    assert portfolio.get_position(symbol) == quantity
    assert len(portfolio.get_transaction_history()) == 1
```

#### 1.2 æ¸¬è©¦æ•¸æ“šç®¡ç†
```python
import pytest

@pytest.fixture
def sample_market_data():
    """æ¸¬è©¦ç”¨å¸‚å ´æ•¸æ“š."""
    return {
        'AAPL': {'price': 150.0, 'volume': 1000000},
        'GOOGL': {'price': 2500.0, 'volume': 500000},
        'TSLA': {'price': 800.0, 'volume': 2000000}
    }

@pytest.fixture
def mock_portfolio():
    """æ¸¬è©¦ç”¨æŠ•è³‡çµ„åˆ."""
    portfolio = Portfolio(100000)
    portfolio.add_position('AAPL', 100, 150.0)
    portfolio.add_position('GOOGL', 10, 2500.0)
    return portfolio

def test_portfolio_total_value(mock_portfolio, sample_market_data):
    """æ¸¬è©¦æŠ•è³‡çµ„åˆç¸½å€¼è¨ˆç®—."""
    total_value = mock_portfolio.get_total_value(
        {symbol: data['price'] for symbol, data in sample_market_data.items()}
    )
    
    expected_value = 100000 + (100 * 150.0) + (10 * 2500.0)  # ç¾é‡‘ + æŒå€‰åƒ¹å€¼
    assert total_value == expected_value
```

### 2. æ¨¡æ“¬å’Œå­˜æ ¹

#### 2.1 å¤–éƒ¨ä¾è³´æ¨¡æ“¬
```python
from unittest.mock import Mock, patch

def test_trading_strategy_with_mock_data():
    """ä½¿ç”¨æ¨¡æ“¬æ•¸æ“šæ¸¬è©¦äº¤æ˜“ç­–ç•¥."""
    # æ¨¡æ“¬å¸‚å ´æ•¸æ“šæœå‹™
    mock_data_service = Mock()
    mock_data_service.get_current_price.return_value = 150.0
    mock_data_service.get_sma.return_value = 145.0
    
    strategy = MovingAverageStrategy(data_service=mock_data_service)
    
    # æ¸¬è©¦è²·å…¥ä¿¡è™Ÿ
    signal = strategy.generate_signal('AAPL')
    
    assert signal == 'buy'
    mock_data_service.get_current_price.assert_called_with('AAPL')
    mock_data_service.get_sma.assert_called_with('AAPL', 20)

@patch('src.external.broker_api.place_order')
def test_order_execution(mock_place_order):
    """æ¸¬è©¦è¨‚å–®åŸ·è¡Œ."""
    mock_place_order.return_value = {'order_id': '12345', 'status': 'filled'}
    
    executor = TradeExecutor()
    result = executor.execute_trade('AAPL', 100, 150.0)
    
    assert result['order_id'] == '12345'
    mock_place_order.assert_called_once()
```

## ğŸ”’ å®‰å…¨æœ€ä½³å¯¦è¸

### 1. æ•æ„Ÿè³‡æ–™è™•ç†

#### 1.1 é…ç½®ç®¡ç†
```python
import os
from typing import Optional

class Config:
    """å®‰å…¨çš„é…ç½®ç®¡ç†."""
    
    def __init__(self):
        self._api_key: Optional[str] = None
        self._secret_key: Optional[str] = None
    
    @property
    def api_key(self) -> str:
        """ç²å– API é‡‘é‘°."""
        if self._api_key is None:
            self._api_key = os.getenv('TRADING_API_KEY')
            if not self._api_key:
                raise ValueError("TRADING_API_KEY ç’°å¢ƒè®Šæ•¸æœªè¨­å®š")
        return self._api_key
    
    @property
    def secret_key(self) -> str:
        """ç²å–å¯†é‘°."""
        if self._secret_key is None:
            self._secret_key = os.getenv('TRADING_SECRET_KEY')
            if not self._secret_key:
                raise ValueError("TRADING_SECRET_KEY ç’°å¢ƒè®Šæ•¸æœªè¨­å®š")
        return self._secret_key

# âŒ ä¸è¦ç¡¬ç·¨ç¢¼æ•æ„Ÿè³‡æ–™
# API_KEY = "your_api_key_here"

# âœ… ä½¿ç”¨ç’°å¢ƒè®Šæ•¸
config = Config()
api_key = config.api_key
```

#### 1.2 æ—¥èªŒå®‰å…¨
```python
import logging

def safe_log_trade(symbol: str, quantity: int, price: float, api_key: str):
    """å®‰å…¨åœ°è¨˜éŒ„äº¤æ˜“è³‡è¨Š."""
    # âŒ ä¸è¦è¨˜éŒ„æ•æ„Ÿè³‡æ–™
    # logger.info(f"åŸ·è¡Œäº¤æ˜“: {symbol}, API Key: {api_key}")
    
    # âœ… é®è”½æ•æ„Ÿè³‡æ–™
    masked_key = api_key[:4] + '*' * (len(api_key) - 8) + api_key[-4:]
    logger.info(
        "åŸ·è¡Œäº¤æ˜“ - è‚¡ç¥¨: %s, æ•¸é‡: %d, åƒ¹æ ¼: %.2f, API Key: %s",
        symbol, quantity, price, masked_key
    )
```

### 2. è¼¸å…¥é©—è­‰

#### 2.1 åƒæ•¸é©—è­‰
```python
from decimal import Decimal
import re

def validate_symbol(symbol: str) -> str:
    """é©—è­‰è‚¡ç¥¨ä»£ç¢¼."""
    if not symbol:
        raise ValueError("è‚¡ç¥¨ä»£ç¢¼ä¸èƒ½ç‚ºç©º")
    
    if not re.match(r'^[A-Z]{1,5}$', symbol.upper()):
        raise ValueError("è‚¡ç¥¨ä»£ç¢¼æ ¼å¼ç„¡æ•ˆ")
    
    return symbol.upper()

def validate_price(price: float) -> Decimal:
    """é©—è­‰åƒ¹æ ¼."""
    if price <= 0:
        raise ValueError("åƒ¹æ ¼å¿…é ˆå¤§æ–¼é›¶")
    
    if price > 1000000:  # åˆç†çš„åƒ¹æ ¼ä¸Šé™
        raise ValueError("åƒ¹æ ¼è¶…å‡ºåˆç†ç¯„åœ")
    
    # ä½¿ç”¨ Decimal é¿å…æµ®é»æ•¸ç²¾åº¦å•é¡Œ
    return Decimal(str(price))

def validate_quantity(quantity: int) -> int:
    """é©—è­‰æ•¸é‡."""
    if not isinstance(quantity, int):
        raise TypeError("æ•¸é‡å¿…é ˆç‚ºæ•´æ•¸")
    
    if quantity <= 0:
        raise ValueError("æ•¸é‡å¿…é ˆå¤§æ–¼é›¶")
    
    if quantity > 1000000:  # åˆç†çš„æ•¸é‡ä¸Šé™
        raise ValueError("æ•¸é‡è¶…å‡ºåˆç†ç¯„åœ")
    
    return quantity
```

## ğŸ“ˆ æ€§èƒ½æœ€ä½³å¯¦è¸

### 1. è³‡æ–™çµæ§‹é¸æ“‡

#### 1.1 é©ç•¶çš„è³‡æ–™çµæ§‹
```python
# âœ… ä½¿ç”¨é©ç•¶çš„è³‡æ–™çµæ§‹
from collections import defaultdict, deque
import bisect

class PriceHistory:
    """åƒ¹æ ¼æ­·å²ç®¡ç†."""
    
    def __init__(self, max_size: int = 1000):
        self.prices = deque(maxlen=max_size)  # å›ºå®šå¤§å°çš„ä½‡åˆ—
        self.timestamps = deque(maxlen=max_size)
        self._sorted_prices = []  # ç”¨æ–¼å¿«é€ŸæŸ¥æ‰¾ä¸­ä½æ•¸
    
    def add_price(self, price: float, timestamp: datetime):
        """æ·»åŠ åƒ¹æ ¼æ•¸æ“š."""
        self.prices.append(price)
        self.timestamps.append(timestamp)
        
        # ç¶­è­·æ’åºåˆ—è¡¨ç”¨æ–¼çµ±è¨ˆè¨ˆç®—
        bisect.insort(self._sorted_prices, price)
        if len(self._sorted_prices) > self.max_size:
            self._sorted_prices.pop(0)
    
    def get_median(self) -> float:
        """ç²å–ä¸­ä½æ•¸ - O(1) æ™‚é–“è¤‡é›œåº¦."""
        n = len(self._sorted_prices)
        if n == 0:
            return 0.0
        
        if n % 2 == 1:
            return self._sorted_prices[n // 2]
        else:
            return (self._sorted_prices[n // 2 - 1] + self._sorted_prices[n // 2]) / 2
```

### 2. å¿«å–ç­–ç•¥

#### 2.1 è¨˜æ†¶åŒ–è£é£¾å™¨
```python
from functools import lru_cache
import time

@lru_cache(maxsize=128)
def calculate_technical_indicator(symbol: str, period: int, 
                                indicator_type: str) -> float:
    """è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ï¼ˆå¸¶å¿«å–ï¼‰."""
    # æ˜‚è²´çš„è¨ˆç®—æ“ä½œ
    time.sleep(0.1)  # æ¨¡æ“¬è¨ˆç®—æ™‚é–“
    return 42.0  # æ¨¡æ“¬çµæœ

# ä½¿ç”¨æ™‚é–“æ•æ„Ÿçš„å¿«å–
class TimedCache:
    """å¸¶æ™‚é–“éæœŸçš„å¿«å–."""
    
    def __init__(self, ttl_seconds: int = 300):
        self.cache = {}
        self.ttl = ttl_seconds
    
    def get(self, key: str):
        """ç²å–å¿«å–å€¼."""
        if key in self.cache:
            value, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return value
            else:
                del self.cache[key]
        return None
    
    def set(self, key: str, value):
        """è¨­å®šå¿«å–å€¼."""
        self.cache[key] = (value, time.time())

# å…¨åŸŸå¿«å–å¯¦ä¾‹
market_data_cache = TimedCache(ttl_seconds=60)  # 1åˆ†é˜éæœŸ
```

## ğŸ”— ç›¸é—œè³‡æº

### æ–‡æª”é€£çµ
- [é–‹ç™¼è€…å“è³ªæ¨™æº–æŒ‡å—](../é–‹ç™¼è€…æŒ‡å—/å“è³ªæ¨™æº–.md)
- [å“è³ªæª¢æŸ¥å·¥å…·ä½¿ç”¨æ‰‹å†Š](../å·¥å…·ä½¿ç”¨æ‰‹å†Š/å“è³ªæª¢æŸ¥å·¥å…·.md)
- [å¸¸è¦‹å•é¡Œè§£ç­”](../Q&Aå¸¸è¦‹å•é¡Œ.md)

### å¤–éƒ¨è³‡æº
- [Clean Code by Robert Martin](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350884)
- [Effective Python by Brett Slatkin](https://effectivepython.com/)
- [Python Design Patterns](https://python-patterns.guide/)
- [PEP 8 Style Guide](https://pep8.org/)
